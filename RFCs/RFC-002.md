# RFC 002: Asynchronous World Generation Pipeline
- Feature Name: `async_world_gen_pipeline`
- Start Date: 2026-02-16
- Status: Draft

## Summary
This RFC proposes a Stage-Based State Machine for world generation. Instead of a monolithic "generate chunk" function, world generation is broken into discrete steps: Terrain -> Biomes -> Surface -> Features -> Light -> Done.

We introduce a `GenStatus` component that tracks a chunk's progress. ECS Systems query for chunks at specific stages, perform work, and advance the state. This allows generation to be fully asynchronous, parallelized across threads, and lazy (pausing when no players are near).

## Motivation
In the legacy server model, world generation is often synchronous or blocks the main thread when populating features (like trees) or calculating initial lighting. This leads to:
1. Lag Spikes: Generating a jungle freezes the server because trees cascade into unloaded chunks.
2. Lighting Lag: When a player teleports to a new terrain, the server often stalls to calculate light maps before sending the packet, or sends dark chunks that "pop" into light later.
3. Deadlocks: Circular dependencies where Chunk A waits for Chunk B to generate light, which waits for Chunk A to generate trees.
By using an ECS Pipeline, we decouple the request for a chunk from the work of generating it.

## Detailed Design
### 1. The `GenStatus` Component
Every chunk entity has a state component indicating its generation progress.
```rust
#[derive(Component, PartialEq, PartialOrd, Debug, Clone, Copy)]
pub enum GenStatus {
    New,            // Just spawned, no data
    Structure,      // Base terrain (stone/water/air) calculated via noise
    Biomes,         // Biome IDs assigned (temperature/humidity/voronoi)
    Surface,        // Grass/Dirt/Sand placed on top of stone
    Features,       // Trees, ores, flowers placed (Requires neighbors!)
    Light,          // Sky light & Block light propagated (Requires neighbors!)
    Done,           // Fully generated, ready for players/saving
}
```

### 2. The Pipeline Systems
We define distincet ECS Systems for each stage. These run in parallel on the thread pool (e.g., `rayon` or `bevy::tasks`).

#### A. `TerrainShapeSystem`
- Query: `With<GenStatus::New>`
- Action: Calculates 3D noise (Simplex/Perlin). Fills the VoxelStorage with Stone, Water, or Air.
- Transition: Sets `GenStatus::Structure`.
- Dependencies: None (Pure math).

#### B. `BiomeSystem`
- Query: `With<GenStatus::Structure>`
- Action: Calculates Voronoi cells or noise maps to assign a Biome ID to each column.
- Transition: Sets `GenStatus::Biomes`

#### C. `FeatureSystem` (Neighbor Dependent)
- Query: `With<GenStatus::Surface>`
- Action: Places objects (trees, ores).
- Constraint: Neighbor Chunk (3x3) A Chunk cannot enter the features stage until all 8 surrounding neighbors are at least in the `Surface` stage.
- Reasoning: A tree generated at local x = 15 might extend into neighbor x=0. If the nieghbor doesn't exist, the tree is cut off.
- Transition: Sets `GenStats::Features`

#### D. `LightingSystem`
- Query: `With<GenStatus::Features>`
- Action: 1. Initialize: Set initial light values (e.g., 15 for sky, 0 for blocks). 2. Propagate: Run the lighting engine (e.g., a BFD flood-fill) to spread the light through air blocks and transparent objects.
- Constraint: Neighbor Check (3x3) A chunk cannot enter the `Light` stage until all 8 neighbors are in the `Features` stage (i.e., they have their trees/caves).
- Reasoning: Light spills across chunk boundaries. If we calculate light before the neighbor has trees, the shadows will be wrong.
- Transition: Sets `GenStatus::Light` (which effectively means "Ready for Done").

### 3. The `RegionView` Abstraction
To safely allow features and light to cross boundaries, we do not pass a single `Chunk` to the generator. We pass a `Region`.
```rust
pub trait FeatureGenerator {
    /// Places a feature (e.g., a tree) into the world.
    /// `region` allows writing to the center chunk AND its neighbors.
    fn place(&self, region: &mut RegionView, seed: u64, pos: BlockPos);
}

pub struct RegionView<'a> {
    pub center: Mut<VoxelStorage>,
    pub neighbors: [Mut<VoxelStorage>; 8], // The surrounding 3x3 grid
}
```
### 4. The `WorldGen` Resource
A global resource holds the configuration for the pipeline. This is where data-driven design comes in.
```rust
#[derive(Resource)]
pub struct WorldGenConfig {
    pub seed: u64,
    pub noise_settings: NoiseConfig,
    /// Registry of features to run during the Feature stage
    pub features: Vec<Box<dyn FeatureGenerator>>, 
}
```
## Drawbacks
1. Latency: Adding a dedicated `Light` stage increases the time from "Chunk Requested" to "chunk visible". However, since this happens async, the server tick rate is unaffected.
2. Memory Pressure: THe `Light` stage requires a center chunk + 8 neighbors to be loaded with `VoxelStorage` and `LightVolume` components. This creates a "9-chunk footprint" for ever chunk being generated.

## Unresolved Questions
- Carvers (Caves/Ravines): Where do they fit? They usually remove blocks (air) rather than adding them. Should they be a "Pre-Feature" stage or part of `Structure`?
  - I'm leaning towards treating them as a `Structure` post-processing (modifying the noise result) before `Surface` generation.
