# RFC 001: ECS Chunk Architecture & Zero-Copy Persistence
- Feature name: ecs_chunk_model
- Start date: 2026-02-16
- Status: Draft

## Summary

This RFC proposes a ECS optimized method to represent world data. Instead of treating Chunks as complex Objects (like standard Java-esque implementations), we define the Chunk as a set of ECS Components attached to a "Chunk Entity".

Furthermore, we propose replacing the legacy Anvil file format with a Key-Value Store (LMDB/RocksDB) using Zero-Copy Serialization (`rkyv`). This ensures that loading a chunk is effectively a memory mapping operation, bypassing costly parsing and deserialization steps.

## Motivation
The current standard for Minecraft server architecture (originating from the vanilla Java server) suffers from several critical performance bottlenecks:

1. Object Overhead: In vanilla, chunks are objects containing arrays of objects (BlockStates). This causes massive pointer chasing and cache misses.

2. Serialization Cost: The Anvil format (NBT/GZIP) requires parsing complex tree structures every time a chunk is loaded or saved. This is CPU-intensive and generates garbage.

3. Concurrency Locking: Modifying a block in a vanilla chunk usually requires lockign the entire chunk object, preventing other threads (liek physics or lighting) from reading it safely.

By moving to an ECS-based model with Zero-Copy Persistence, we aim to achieve:

- Cache Locality: Chunk data is stored in contiguous arrays (SoA), friendly to CPU caches.
- Instant Loading: Loading a Chunkj from disk becomes a `memcpy` (or `mmap`) operation.
- Parallelism: Systems can query specific components (e.g., `LightingSystem` only requests `LightVolume`) without locking the voxel data.

## Detailed Design

1. The Chunk as an Entity
A "Chunk" is no longer a struct. It is an Entity ID. The data resides in components attached to this ID.

#### Core Components
We will define the following components for a standard 16x16x16 chunk section:
```rust
/// The spatial identifier for the chunk.
/// Ideally packed into a single u64 for fast hashing/lookups.
#[derive(Component)]
pub struct ChunkPosition {
    pub x: i32,
    pub y: i32,
    pub z: i32,
    pub dimension: EntityId, 
}

/// The actual block data.
/// Uses a Paletted Container strategy to save memory.
#[derive(Component)]
pub struct VoxelStorage {
    /// Global palette IDs (mapping local index -> global block ID)
    pub palette: Vec<u16>, 
    /// Bit-packed indices pointing into the palette.
    /// Using a BitVec allows dynamic resizing based on palette size (4 bits, 8 bits, etc).
    pub data: BitVec, 
}

/// Lighting data, separated so it can be updated independently of voxels.
#[derive(Component)]
pub struct LightVolume {
    pub sky_light: [u8; 2048], // Nibble-packed array
    pub block_light: [u8; 2048],
}

/// Operational state metadata.
#[derive(Component)]
pub enum ChunkState {
    Clean,          // Matches disk
    Dirty,          // Needs saving
    Generating(u8), // In generation pipeline (Stage ID)
}
```

### 2. The Storage Layer (Persistence)
We will abandon the region file format (Anvil) in favor of a embeded Key-Value store.
- Database: LMDB or RocksDB.
- Key format: A `u64` bit-packed Z-Order Curve (Morton Code) of `(x, z)`. This ensures that chunks physically close in the world are physically close in the database B-Tree, maximizing read performance during player movement.

#### Zero-Copy Serialization (`rkyv`)
We will use the `rkyv` crate for serialization. Unlike Serde (JSON/NBT),`rkyv` guarantees that the in-memory representation of a struct is identitical to its on-disk representation.

#### The Workflow:
1. **Save:** The `PersistenceSystem` queries `(VoxelStorage, LightVolume)` where `ChunkState == Dirty`. It casts the memory directly to bytes and writes to the DB.
2. **Load:** The system reads bytes from the DB. It does _not_ parse them. It casts the pointer to a `&ArchivedChunk` struct. This is effectively instant (*O*)1).

```rust
// The on-disk schema (Archived version generated by rkyv)
#[derive(Archive, Deserialize, Serialize)]
pub struct DiskChunk {
    pub palette: Vec<u16>,
    pub packed_voxels: Vec<u64>,
    pub sky_light: Vec<u8>,
    pub block_light: Vec<u8>,
}
```

### 3. The "Archetype" Optimization
To prevent memory bloat, we will leverage ECS Archetypes to distinguish between "Active" and "Cached" chunks.
- Active Chunk Archetype: Contains `VoxelStorage` (Decompressed `BitVec`), `LightVolume`, `Collider`, `Mesh`.
    - Used for: Chunks around players, ticking chunks.
- Cached Chunk Archetype: Contains only `CompressedChunkBlob` (Raw bytes from DB).
    - Used for: Chunks at the edge of render distance or currently being saved. THe data is in memory, but not expanded into usable components.

## Drawbacks
1. Schema Rigidity: `rkyv` is sensitive to struct layout changes. If we change `DiskChunk` fields, old database files will become unreadable garbage. We must implement a versioning/migration strategy (e.g., a schema version byte header).
2. Debuggability: Unlike NBT or JSON, the database data will be raw binary bytes. We cannot open it in a text editor. We will need to write a custom CLI tool (`strata-cli inspect chunk <x> <z>`) to debug world saves.
3. Complexity: Paletted storage with bit-packing is significantly harder to implement than a simple `[u16; 4096]` array.

## Alternatives Considered
- Keep Anvil (NBT): Easiest for interoperability, but performance is unacceptable for our goals. The I/O overhead of GZipping NBT blobs is a known bottleneck in vanilla.
- Protobuf / Cap'n Proto: Faster than JSON, but still requires a decoding step. `rkyv` beats them in raw throughput by avoiding the decoding step entirely.
- Flat Arrays: Storing raw `u16` arrays for blocks avoids bit-packing complexity but increases memory usage by 4x-8x. Given that memory bandwidth is often the bottleneck, compression (via palettes) is preferred.

